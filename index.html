<!doctype html>
<html>
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

        <title>ES2015 (part 2)</title>

        <link rel="stylesheet" href="css/reveal.css">
        <link rel="stylesheet" href="css/theme/simple.css">

        <link rel="stylesheet" href="css/custom.css">

        <!-- Theme used for syntax highlighting of code -->
        <link rel="stylesheet" href="lib/css/zenburn.css">

        <!-- Printing and PDF exports -->
        <script>
            var link = document.createElement( 'link' );
            link.rel = 'stylesheet';
            link.type = 'text/css';
            link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
            document.getElementsByTagName( 'head' )[0].appendChild( link );
        </script>
    </head>
    <body>
        <div class="reveal">
            <div class="slides">

                <section>
                    <h1>
                        ES2015<br>
                        <small>(part 2)</small>
                    </h1>
                    <p>
                        <a href="http://abbekeultjes.nl/">
                            <img src="img/logo-abbe.svg"><br>
                            <small>
                                Abbe Keultjes<br>
                                Frontmen
                            </small>
                        </a>
                    </p>
                    <p>
                        <small><a href="https://github.com/flauwekeul/presentation-es2015-part-2">github.com/flauwekeul/presentation-es2015-part-2</a></small>
                    </p>
                </section>

                <section>
                    <section>
                        <h2>Overview</h2>
                        <ol>
                            <li>
                                <a href="#/iterators-and-iterables">Iterators and iterables</a>
                            </li>
                            <li>
                                <a href="#/generators">Generators</a>
                            </li>
                            <li>
                                <a href="#/modules">Modules</a>
                            </li>
                            <li>
                                <a href="#/classes">"Classes"</a>
                            </li>
                            <li>
                                <a href="#/maps-and-sets"><code>Map</code>s and <code>Set</code>s</a>
                            </li>
                            <li>
                                <a href="#/api-additions">API additions</a>
                            </li>
                            <li>
                                <a href="#/proxies-and-the-reflect-api">Proxies and the <code>Reflect</code> API</a>
                            </li>
                        </ol>
                    </section>
                </section>

                <section id="iterators-and-iterables">
                    <section>
                        <h2>Iterators and iterables</h2>
                    </section>
                    <section>
                        <h3>What's an iterator?</h3>
                        <blockquote cite="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators#Iterators">
                            <p>
                                An object is an iterator when it knows how to access items from a collection one at a time, while keeping track of its current position within that sequence.
                                <span class="fragment" data-fragment-index="1">In JavaScript an iterator is an object that provides a <code>next()</code> method which returns the next item in the sequence. This method returns an object with two properties: <code>done</code> and <code>value</code>.</span>
                            </p>
                            <small class="fragment" data-fragment-index="1">
                                <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators#Iterators">MDN</a>
                            </small>
                        </blockquote>
                    </section>
                    <section>
                        <h3>An example</h3>
                        <pre><code data-trim data-noescape class="js">
                            const array = [1, 2, 3]
                            const iterator = array[Symbol.iterator]()

                            <span class="fragment" data-fragment-index="1">console.log(iterator.next()) // { value: 1, done: false }</span>
                            <span class="fragment" data-fragment-index="2">console.log(iterator.next()) // { value: 2, done: false }</span>
                            <span class="fragment" data-fragment-index="3">console.log(iterator.next()) // { value: 3, done: false }</span>

                            <span class="fragment" data-fragment-index="4">console.log(iterator.next()) // { value: undefined, done: true }</span>
                            <span class="fragment" data-fragment-index="5">
                            const aNewIterator = array[Symbol.iterator]()
                            console.log(aNewIterator.next()) // { value: 1, done: false }
                            </span>
                        </code></pre>
                        <p class="fragment" data-fragment-index="5">A new fresh iterator can be created from the same iterable.</p>
                    </section>
                    <section>
                        <h3>Iterators and iterables?</h3>
                        <pre><code data-trim data-noescape class="js">
                            const iterable = [1, 2, 3]
                            <span class="fragment" data-fragment-index="1">const alsoAnIterable = 'hello'</span>
                            <span class="fragment" data-fragment-index="2">
                            const iterator1 = iterable[Symbol.iterator]()
                            const iterator2 = alsoAnIterable[Symbol.iterator]()
                            console.log(iterator1) // Array Iterator {}
                            console.log(iterator2) // StringIterator {}
                            </span><span class="fragment" data-fragment-index="3">
                            const notAnIterable = {}
                            notAnIterable[Symbol.iterator]() // ⚠️ TypeError
                            </span>
                        </code></pre>
                        <ul>
                            <li>
                                All arrays are iterable<span class="fragment" data-fragment-index="1">, as are strings. <small>(also: maps, sets and generators)</small></span>
                            </li>
                            <li class="fragment" data-fragment-index="2">
                                An iterable is just an object that can produce an iterator.
                            </li>
                            <li class="fragment" data-fragment-index="3">
                                Regular objects are not iterable by default.
                            </li>
                        </ul>
                    </section>
                    <section>
                        <h3>Iterator consumption</h3>
                        <p>Iterators can be consumed by several JS structures:</p>
                        <pre><code data-trim data-noescape class="js">
                            <span class="fragment">const anIterable = 'yeah'</span>
                            <span class="fragment">
                            // for..of loops:
                            for (let value of anIterable) {
                                // ...
                            }</span>
                            <span class="fragment">
                            // the spread operator:
                            console.log(...anIterable) // y e a h
                            </span><span class="fragment">
                            // array destructuring:
                            const [ x, y, ...rest ] = anIterable
                            console.log(x, y, rest) // y e ['a', 'h']
                            </span>
                        </code></pre>
                    </section>
                </section>

                <section id="generators">
                    <section>
                        <h2>Generators</h2>
                    </section>
                    <section>
                        <h3>What is it?</h3>
                        <p class="fragment">A generator is a special function that can be paused to resume execution later. When pausing and resuming, values can be exchanged.</p>
                    </section>
                    <section>
                        <h3>Syntax</h3>
                        <pre><code data-trim data-noescape class="js">
                            function *foo()  { }
                            <span class="fragment" data-fragment-index="1">function* foo()  { }</span>
                            <span class="fragment" data-fragment-index="2">function * foo() { }</span>
                            <span class="fragment" data-fragment-index="3">function*foo()   { }</span>
                            <span class="fragment" data-fragment-index="4">
                            const object = {
                                *foo() { }
                            }
                            </span>
                        </code></pre>
                        <p class="fragment" data-fragment-index="3">Functionally, it doesn't matter where the <code>*</code> is placed.</p>
                        <p class="fragment" data-fragment-index="4">The syntax is similar for the concise form.</p>
                    </section>
                    <section>
                        <h3>Using generators</h3>
                        <div class="cols">
                            <div class="col">
                                <pre><code data-trim data-noescape class="js">
                                    function *aGenerator() {
                                        console.log('before yield')

                                        <span class="fragment" data-fragment-index="1">yield</span>

                                        console.log('after yield')
                                    }

                                    <span class="fragment" data-fragment-index="2">const iterator = aGenerator()</span>

                                    <span class="fragment" data-fragment-index="3">iterator.next()
                                    // 'before yield'</span>
                                    <span class="fragment" data-fragment-index="4">iterator.next()
                                    // 'after yield'</span>
                                </code></pre>
                            </div>
                            <div class="col">
                                <ul class="small">
                                    <li class="fragment" data-fragment-index="1">Generators are paused using the <code>yield</code> keyword.</li>
                                    <li class="fragment" data-fragment-index="2">They are called like regular functions, but they return an iterator.</li>
                                    <li class="fragment" data-fragment-index="3">When the iterator's <code>next()</code> method is called, the code up to the <code>yield</code> statement is executed.</li>
                                    <li class="fragment" data-fragment-index="4">When the <code>next()</code> method is called again, the code after the <code>yield</code> statement is executed.</li>
                                </ul>
                            </div>
                        </div>
                    </section>
                    <section>
                        <h3>Exchanging values</h3>
                        <pre><code data-trim data-noescape class="js">
                            function *passValues() {
                                const received = yield 'output'
                                console.log('received: ', received)
                            }

                            const iterator = passValues()
                            <span class="fragment" data-fragment-index="1">
                            console.log(iterator.next()) // { value: 'output', done: false }</span>
                            <span class="fragment" data-fragment-index="2">console.log(iterator.next('input'))
                            // 'received: input'
                            // { value: undefined, done: true }</span>
                        </code></pre>
                        <ul>
                            <li class="fragment" data-fragment-index="1">
                                Once the code reaches <code>yield</code>, it sends out a value.
                            </li>
                            <li class="fragment" data-fragment-index="2">
                                When the generator is resumed, a value can be passed to the <code>next()</code> method.
                                This "replaces" the whole <code>yield</code> statement.
                            </li>
                        </ul>
                    </section>
                    <section>
                        <h3><code>return()</code></h3>
                        <pre><code data-trim data-noescape class="js">
                            function *generator() {
                                try {
                                    yield 1
                                    yield 2
                                } finally {
                                    console.log('done')
                                }
                            }
                            const iterator = generator()
                            <span class="fragment" data-fragment-index="1">console.log(iterator.next()) // { value: 1, done: false }</span>
                            <span class="fragment" data-fragment-index="2">console.log(iterator.return('abort'))</span>
                            <span class="fragment" data-fragment-index="3">// 'done'</span>
                            <span class="fragment" data-fragment-index="4">// { value: 'abort', done: true }</span>
                            <span class="fragment" data-fragment-index="5">console.log(iterator.next()) // { value: undefined, done: true }</span>
                        </code></pre>
                        <p class="fragment" data-fragment-index="2">
                            <code>return()</code> optionally accepts a value<span class="fragment" data-fragment-index="3">, executes the <code>finally</code> block (if any)</span><span class="fragment" data-fragment-index="4">, returns that value</span><span class="fragment" data-fragment-index="5"> and aborts the generator.</span>
                        </p>
                    </section>
                    <section>
                        <h3><code>throw()</code></h3>
                        <pre><code data-trim data-noescape class="js">
                            function *generator() {
                                try {
                                    yield 1
                                    yield 2
                                } catch (error) {
                                    console.log(error)
                                }
                            }
                            const iterator = generator()
                            <span class="fragment" data-fragment-index="1">console.log(iterator.next()) // { value: 1, done: false }</span>
                            <span class="fragment" data-fragment-index="2">console.log(iterator.throw('exception!'))</span>
                            <span class="fragment" data-fragment-index="3">// 'exception!'
                            // { value: undefined, done: true }</span>
                            <span class="fragment" data-fragment-index="4">console.log(iterator.next()) // { value: undefined, done: true }</span>
                        </code></pre>
                        <p class="fragment" data-fragment-index="2">
                            <code>throw()</code> also optionally accepts a value<span class="fragment" data-fragment-index="3">, executes the <code>catch</code> block (if any)</span><span class="fragment" data-fragment-index="4"> and aborts the generator.</span>
                        </p>
                    </section>
                    <!-- <section>
                        <h3>Yield delegation</h3>
                        <p>TODO</p>
                    </section>
                    <section>
                        <h3>Synchronous looking asynchronicity</h3>
                        <p>TODO</p>
                    </section> -->
                </section>

                <section id="modules">
                    <section>
                        <h2>Modules</h2>
                    </section>
                    <section>
                        <h3>Before ES2015</h3>
                        <p>There are several module patterns.</p>
                        <ul>
                            <li class="fragment">
                                Asynchronous Module Definition (AMD)
                                <pre><code data-trim class="js">
                                    define(['someDependency'], function (someDependency) {
                                        return someFunction() { }
                                    })
                                </code></pre>
                            </li>
                            <li class="fragment">
                                CommonJS (mainly used by Node)
                                <pre><code data-trim class="js">
                                    const someDependency = require('someDependency')
                                    module.exports = someFunction() { }
                                </code></pre>
                            </li>
                            <li class="fragment">
                                Universal Module Definition (UMD): supports both AMD and CommonJS
                            </li>
                        </ul>
                    </section>
                    <section>
                        <h3>Exporting: named exports</h3>
                        <pre class="fragment" data-fragment-index="1"><code data-trim data-noescape class="js">
                            export function someFunction() { }
                            <span class="fragment" data-fragment-index="2">export let someString = 'hey'</span>
                            <span class="fragment" data-fragment-index="3">
                            const someArray = [1, 2, 3]
                            const someNumber = 10
                            // export multiple members:
                            export { someArray, someNumber }
                            </span><span class="fragment" data-fragment-index="4">
                            // with a different name:
                            const anotherArray = [4, 5, 6]
                            export { anotherArray as blah }
                            </span><span class="fragment" data-fragment-index="5">
                            // later:
                            someString = 'something else'
                            </span>
                        </code></pre>
                        <p class="fragment" data-fragment-index="5">Members are exported as <em>bindings</em>: if changed later, the imported value changes too.</p>
                    </section>
                    <section>
                        <h3>Exporting: default exports</h3>
                        <pre class="fragment" data-fragment-index="1"><code data-trim data-noescape class="js">
                            function someFunction() { }
                            export default someFunction
                            <span class="fragment" data-fragment-index="3">
                            export function anotherFunction() { }
                            export function andAnother() { }
                            </span>
                        </code></pre>
                        <ul>
                            <li class="fragment" data-fragment-index="2">There can be only one <code>default</code> per module</li>
                            <li class="fragment" data-fragment-index="3">But it's possible to also have more non-default <code>export</code>s</li>
                        </ul>
                        <p class="fragment" data-fragment-index="4">My advice:</p>
                        <ul>
                            <li class="fragment" data-fragment-index="4">
                                either have a single default <code>export</code> <strong>or</strong>&hellip;
                            </li>
                            <li class="fragment" data-fragment-index="5">
                                multiple non-default <code>export</code>s per module</p>
                            </li>
                        </ul>
                    </section>
                    <section>
                        <h3>Importing</h3>
                        <pre class="fragment" data-fragment-index="1"><code data-trim data-noescape class="js">
                            // import multiple named members:
                            import { someFunction, someString } from 'someModule'
                            <span class="fragment" data-fragment-index="2">
                            // rename an imported member:
                            import { someArray as array } from 'anotherModule'
                            </span><span class="fragment" data-fragment-index="3">
                            // import a single default member:
                            import someDefault from 'moduleWithDefault'
                            </span><span class="fragment" data-fragment-index="4">
                            // import a default member and non-default members:
                            import anotherDefault, { someNumber, someVar } from 'mixedModule'
                            </span><span class="fragment" data-fragment-index="5">
                            // a "namespace import" imports <strong>all</strong> members:
                            import * as everything from 'lotsOfMembers'
                            console.log(everything) // { a: 'a', b: 1, c: function c() { } }
                            </span>
                        </code></pre>
                        <p class="fragment" data-fragment-index="6">Imported members are immutable.</p>
                    </section>
                    <section>
                        <h3>Things to keep in mind</h3>
                        <p>ES2015 modules:</p>
                        <ul>
                            <li class="fragment">
                                &hellip;are <strong>file-based</strong>: one module per file.
                            </li>
                            <li class="fragment">
                                &hellip;are <strong>static</strong>: members can't be added/removed dynamically.
                            </li>
                            <li class="fragment">
                                &hellip;are <strong>singletons</strong>: there's one instance of each module, which maintains its state.
                            </li>
                            <li class="fragment">
                                &hellip;support <strong>circular dependencies</strong>: e.g. A imports B and B imports A.
                            </li>
                            <li class="fragment">
                                &hellip;are <strong>very difficult to implement</strong>: no JS runtime currently supports modules.
                            </li>
                        </ul>
                    </section>
                </section>

                <section id="classes">
                    <section>
                        <h2>"Classes"</h2>
                    </section>
                    <section>
                        <h3>Not really though 😒</h3>
                        <p class="fragment" data-fragment-index="1">The word "class" implies <em>class inheritance</em>, but JS still has <em>prototypal inheritance</em>.</p>
                        <pre class="fragment" data-fragment-index="2"><code data-trim data-noescape class="js">
                        class Foo {}
                        console.log(typeof Foo) // function
                        </code></pre>
                        <p class="fragment" data-fragment-index="2"><code>class</code> is just syntactic sugar for a constructor function.</p>
                    </section>
                    <section>
                        <h3><code>class</code> vs. constructor function</h3>
                        <div class="cols">
                            <div class="col fragment small" data-fragment-index="1">
                                <pre><code data-trim data-noescape class="js">
                                    class FooClass {
                                        constructor (a, b) {
                                            this.a = a
                                            this.b = b
                                        }<span class="fragment" data-fragment-index="6"> // ← no comma</span>

                                        aTimesB() {
                                            return this.a * this.b
                                        }
                                    }

                                    const foo = new FooClass(2, 3)
                                    console.log(foo.aTimesB()) // 6
                                </code></pre>
                            </div>
                            <div class="col fragment small" data-fragment-index="2">
                                <pre><code data-trim data-noescape class="js">
                                    function FooConstructor(a, b) {
                                        this.a = a
                                        this.b = b
                                    }

                                    FooConstructor.prototype.aTimesB =
                                        function () {
                                            return this.a * this.b
                                        }


                                    const foo = new FooConstructor(2, 3)
                                    console.log(foo.aTimesB()) // 6
                                </code></pre>
                            </div>
                        </div>
                        <p class="fragment" data-fragment-index="3">Some differences:</p>
                        <ul>
                            <li class="fragment" data-fragment-index="4">
                                Instantiating a <code>class</code> <em>must</em> be done with <code>new</code>.
                            </li>
                            <li class="fragment" data-fragment-index="5">
                                A (constructor) function is hoisted, a <code>class</code> is not.
                            </li>
                        </ul>
                    </section>
                    <section>
                        <h3><code>extends</code> and <code>super</code></h3>
                        <pre class="fragment" data-fragment-index="1"><code data-trim data-noescape class="js small">
                            class Bar extends FooClass {
                                constructor (a, b, c) {
                                    super(a, b)<span class="fragment" data-fragment-index="2"> // here super refers to parent <strong>constructor</strong>: FooClass</span>
                                    this.c = c
                                }

                                aTimesBTimesC() {
                                    <span class="fragment" data-fragment-index="3">// here super refers to parent <strong>object</strong>: FooClass.prototype</span>
                                    return super.aTimesB() * this.c
                                }
                            }

                            const bar = new Bar(2, 3, 4)
                            console.log(bar.aTimesBTimesC()) // 24
                        </code></pre>
                    </section>
                    <section>
                        <h3>Some nuances</h3>
                        <ul>
                            <li class="fragment">
                                <code>super</code> can't be dynamically bound like <code>this</code> can.
                            </li>
                            <li class="fragment">
                                When a class doesn't have a constructor, a default constructor is used. In case of a subclass, the default constructor calls the parent constructor:
                                <pre><code data-trim class="js">
                                    constructor(...args) {
                                        super(...args)
                                    }
                                </code></pre>
                            </li>
                            <li class="fragment">
                                In the constructor of a subclass, you cannot access <code>this</code> until <code>super()</code> has been called.
                            </li>
                        </ul>
                    </section>
                    <section>
                        <h3><code>static</code> methods</h3>
                        <pre class="fragment"><code data-trim data-noescape class="js">
                            class Parent {
                                static foo() { console.log('foo') }
                            }
                            <span class="fragment">
                            class Child extends Parent {
                                static bar() {
                                    super.foo()
                                    console.log('bar')
                                }
                            }</span>

                            <span class="fragment">console.log(Parent.foo()) // 'foo'</span>
                            <span class="fragment">console.log(Child.foo())  // 'foo'</span>
                            <span class="fragment">console.log(Child.bar())  // 'foo' 'bar'</span>
                        </code></pre>
                        <p class="fragment">
                            This works because not only <code>Child.prototype</code> is prototype-linked to <code>Parent.prototype</code>, but <code>Child()</code> is prototype-linked to <code>Parent()</code> too.
                        </p>
                    </section>
                </section>

                <section id="maps-and-sets">
                    <section>
                        <h2><code>Map</code>s and <code>Set</code>s</h2>
                    </section>
                    <section>

                    </section>
                </section>

                <section id="api-additions">
                    <section>
                        <h2>API additions</h2>
                    </section>
                    <section>

                    </section>
                </section>

                <section id="proxies-and-the-reflect-api">
                    <section>
                        <h2>
                            Proxies and the<br>
                            <code>Reflect</code> API
                        </h2>
                    </section>
                    <section>

                    </section>
                </section>

                <section>
                    <h2>The end</h2>
                    <p><small><a href="https://github.com/flauwekeul/presentation-es2015-part-2">github.com/flauwekeul/presentation-es2015-part-2</a></small></p>
                </section>

            </div>
        </div>

        <script src="lib/js/head.min.js"></script>
        <script src="js/reveal.js"></script>

        <script>
            // More info https://github.com/hakimel/reveal.js#configuration
            Reveal.initialize({
                history: true,

                // More info https://github.com/hakimel/reveal.js#dependencies
                dependencies: [
                    { src: 'plugin/markdown/marked.js' },
                    { src: 'plugin/markdown/markdown.js' },
                    { src: 'plugin/notes/notes.js', async: true },
                    { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
                ]
            });
        </script>
    </body>
</html>
