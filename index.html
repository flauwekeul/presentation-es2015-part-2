<!doctype html>
<html>
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

        <title>ES2015 (part 2)</title>

        <link rel="stylesheet" href="css/reveal.css">
        <link rel="stylesheet" href="css/theme/simple.css">

        <link rel="stylesheet" href="css/custom.css">

        <!-- Theme used for syntax highlighting of code -->
        <link rel="stylesheet" href="lib/css/zenburn.css">

        <!-- Printing and PDF exports -->
        <script>
            var link = document.createElement( 'link' );
            link.rel = 'stylesheet';
            link.type = 'text/css';
            link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
            document.getElementsByTagName( 'head' )[0].appendChild( link );
        </script>
    </head>
    <body>
        <div class="reveal">
            <div class="slides">

                <section>
                    <h1>
                        ES2015<br>
                        <small>(part 2)</small>
                    </h1>
                    <p>
                        <img src="img/logo-abbe.svg"><br>
                        <small>
                            Abbe Keultjes<br>
                            Frontmen
                        </small>
                    </p>
                    <p>
                        <small><a href="http://abbekeultjes.nl/presentation-es2015-part-2/">abbekeultjes.nl/presentation-es2015-part-2</a></small>
                    </p>
                </section>

                <section>
                    <section>
                        <h2>Overview</h2>
                        <ol>
                            <li>
                                <a href="#/iterators-and-iterables">Iterators and iterables</a>
                            </li>
                            <li>
                                <a href="#/generators">Generators</a>
                            </li>
                            <li>
                                <a href="#/modules">Modules</a>
                            </li>
                            <li>
                                <a href="#/classes">"Classes"</a>
                            </li>
                            <li>
                                <a href="#/maps-and-sets"><code>Map</code>s and <code>Set</code>s</a>
                            </li>
                            <li>
                                <a href="#/api-additions">API additions</a>
                            </li>
                            <li>
                                <a href="#/proxies-and-the-reflect-api">Proxies and the <code>Reflect</code> API</a>
                            </li>
                        </ol>
                    </section>
                </section>

                <section id="iterators-and-iterables">
                    <section>
                        <h2>Iterators and iterables</h2>
                    </section>
                    <section>
                        <h3>What's an iterator?</h3>
                        <blockquote cite="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators#Iterators">
                            <p>
                                An object is an iterator when it knows how to access items from a collection one at a time, while keeping track of its current position within that sequence.
                                <span class="fragment" data-fragment-index="1">In JavaScript an iterator is an object that provides a <code>next()</code> method which returns the next item in the sequence. This method returns an object with two properties: <code>done</code> and <code>value</code>.</span>
                            </p>
                            <small class="fragment" data-fragment-index="1">
                                <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators#Iterators">MDN</a>
                            </small>
                        </blockquote>
                    </section>
                    <section>
                        <h3>An example</h3>
                        <pre><code data-trim data-noescape class="js">
                            const array = [1, 2, 3]
                            const iterator = array[Symbol.iterator]()

                            <span class="fragment" data-fragment-index="1">console.log(iterator.next()) // { value: 1, done: false }</span>
                            <span class="fragment" data-fragment-index="2">console.log(iterator.next()) // { value: 2, done: false }</span>
                            <span class="fragment" data-fragment-index="3">console.log(iterator.next()) // { value: 3, done: false }</span>

                            <span class="fragment" data-fragment-index="4">console.log(iterator.next()) // { value: undefined, done: true }</span>
                            <span class="fragment" data-fragment-index="5">
                            const aNewIterator = array[Symbol.iterator]()
                            console.log(aNewIterator.next()) // { value: 1, done: false }
                            </span>
                        </code></pre>
                        <p class="fragment" data-fragment-index="5">A new fresh iterator can be created from the same iterable.</p>
                    </section>
                    <section>
                        <h3>Iterators and iterables?</h3>
                        <pre><code data-trim data-noescape class="js">
                            const iterable = [1, 2, 3]
                            <span class="fragment" data-fragment-index="1">const alsoAnIterable = 'hello'</span>
                            <span class="fragment" data-fragment-index="2">
                            const iterator1 = iterable[Symbol.iterator]()
                            const iterator2 = alsoAnIterable[Symbol.iterator]()
                            console.log(iterator1) // Array Iterator {}
                            console.log(iterator2) // StringIterator {}
                            </span><span class="fragment" data-fragment-index="3">
                            const notAnIterable = {}
                            notAnIterable[Symbol.iterator]() // ⚠️ TypeError
                            </span>
                        </code></pre>
                        <ul>
                            <li>
                                All arrays are iterable<span class="fragment" data-fragment-index="1">, as are strings. <small>(also: maps, sets and generators)</small></span>
                            </li>
                            <li class="fragment" data-fragment-index="2">
                                An iterable is just an object that can produce an iterator.
                            </li>
                            <li class="fragment" data-fragment-index="3">
                                Regular objects are not iterable by default.
                            </li>
                        </ul>
                    </section>
                    <section>
                        <h3>Iterator consumption</h3>
                        <p>Iterators can be consumed by several JS structures:</p>
                        <pre class="fragment"><code data-trim data-noescape class="js">
                            const anIterable = 'yeah'
                            <span class="fragment">
                            // for..of loops:
                            for (let value of anIterable) {
                                // ...
                            }</span>
                            <span class="fragment">
                            // the spread operator:
                            console.log(...anIterable) // y e a h
                            </span><span class="fragment">
                            // array destructuring:
                            const [ x, y, ...rest ] = anIterable
                            console.log(x, y, rest) // y e ['a', 'h']
                            </span>
                        </code></pre>
                    </section>
                </section>

                <section id="generators">
                    <section>
                        <h2>Generators</h2>
                    </section>
                    <section>
                        <h3>What is it?</h3>
                        <p class="fragment">A generator is a special function that can be paused to resume execution later. When pausing and resuming, values can be exchanged.</p>
                    </section>
                    <section>
                        <h3>Syntax</h3>
                        <pre><code data-trim data-noescape class="js">
                            function *foo()  { }
                            <span class="fragment" data-fragment-index="1">function* foo()  { }</span>
                            <span class="fragment" data-fragment-index="2">function * foo() { }</span>
                            <span class="fragment" data-fragment-index="3">function*foo()   { }</span>
                            <span class="fragment" data-fragment-index="4">
                            const object = {
                                *foo() { }
                            }
                            </span>
                        </code></pre>
                        <p class="fragment" data-fragment-index="3">Functionally, it doesn't matter where the <code>*</code> is placed.</p>
                        <p class="fragment" data-fragment-index="4">The syntax is similar for the concise form.</p>
                    </section>
                    <section>
                        <h3>Using generators</h3>
                        <div class="cols">
                            <div class="col">
                                <pre><code data-trim data-noescape class="js">
                                    function *aGenerator() {
                                        <span class="fragment" data-fragment-index="1">console.log('before yield')

                                        yield

                                        console.log('after yield')</span>
                                    }

                                    <span class="fragment" data-fragment-index="2">const iterator = aGenerator()</span>

                                    <span class="fragment" data-fragment-index="3">iterator.next()
                                    // 'before yield'</span>
                                    <span class="fragment" data-fragment-index="4">iterator.next()
                                    // 'after yield'</span>
                                </code></pre>
                            </div>
                            <div class="col">
                                <ul class="small">
                                    <li class="fragment" data-fragment-index="1">Generators are paused using the <code>yield</code> keyword.</li>
                                    <li class="fragment" data-fragment-index="2">They are called like regular functions, but they return an iterator.</li>
                                    <li class="fragment" data-fragment-index="3">When the iterator's <code>next()</code> method is called, the code up to the (first) <code>yield</code> statement is executed.</li>
                                    <li class="fragment" data-fragment-index="4">When the <code>next()</code> method is called again, the code after the (first) <code>yield</code> statement is executed.</li>
                                </ul>
                            </div>
                        </div>
                    </section>
                    <section>
                        <h3>Exchanging values</h3>
                        <pre><code data-trim data-noescape class="js">
                            function *passValues() {
                                const received = yield 'output'
                                console.log('received: ', received)
                            }

                            const iterator = passValues()
                            <span class="fragment" data-fragment-index="1">
                            console.log(iterator.next()) // { value: 'output', done: false }</span>
                            <span class="fragment" data-fragment-index="2">console.log(iterator.next('input'))
                            // 'received: input'
                            // { value: undefined, done: true }</span>
                        </code></pre>
                        <ul>
                            <li class="fragment" data-fragment-index="1">
                                Once the code reaches <code>yield</code>, it sends out a value.
                            </li>
                            <li class="fragment" data-fragment-index="2">
                                When the generator is resumed, a value can be passed to the <code>next()</code> method.
                                This "replaces" the whole <code>yield</code> statement.
                            </li>
                        </ul>
                    </section>
                    <section>
                        <h3><code>return()</code></h3>
                        <pre><code data-trim data-noescape class="js">
                            function *generator() {
                                try {
                                    yield 1
                                    yield 2
                                } finally {
                                    console.log('done')
                                }
                            }
                            const iterator = generator()
                            <span class="fragment" data-fragment-index="1">console.log(iterator.next()) // { value: 1, done: false }</span>
                            <span class="fragment" data-fragment-index="2">console.log(iterator.return('abort'))</span>
                            <span class="fragment" data-fragment-index="3">// 'done'</span>
                            <span class="fragment" data-fragment-index="4">// { value: 'abort', done: true }</span>
                            <span class="fragment" data-fragment-index="5">console.log(iterator.next()) // { value: undefined, done: true }</span>
                        </code></pre>
                        <p class="fragment" data-fragment-index="2">
                            <code>return()</code> accepts an optional value<span class="fragment" data-fragment-index="3">, executes the <code>finally</code> block (if any)</span><span class="fragment" data-fragment-index="4">, returns that value</span><span class="fragment" data-fragment-index="5"> and aborts the generator.</span>
                        </p>
                    </section>
                    <section>
                        <h3><code>throw()</code></h3>
                        <pre><code data-trim data-noescape class="js">
                            function *generator() {
                                try {
                                    yield 1
                                    yield 2
                                } catch (error) {
                                    console.log(error)
                                }
                            }
                            const iterator = generator()
                            <span class="fragment" data-fragment-index="1">console.log(iterator.next()) // { value: 1, done: false }</span>
                            <span class="fragment" data-fragment-index="2">console.log(iterator.throw('exception!'))</span>
                            <span class="fragment" data-fragment-index="3">// 'exception!'
                            // { value: undefined, done: true }</span>
                            <span class="fragment" data-fragment-index="4">console.log(iterator.next()) // { value: undefined, done: true }</span>
                        </code></pre>
                        <p class="fragment" data-fragment-index="2">
                            <code>throw()</code> also accepts an optional value<span class="fragment" data-fragment-index="3">, executes the <code>catch</code> block (if any)</span><span class="fragment" data-fragment-index="4"> and aborts the generator.</span>
                        </p>
                    </section>
                    <section>
                        <h3>Yield delegation</h3>
                        <p><code>yield*</code> accepts an iterable and delegates its generators control to its iterator:</p>
                        <pre class="fragment"><code data-trim data-noescape class="js">
                            function *delegate() {
                                yield 1
                                yield 2
                                yield 3
                                return 4
                            }
                            function *generator() {
                                return yield *delegate()
                            }
                            const iterator = generator()

                            <span class="fragment">console.log(iterator.next()) // { value: 1, done: false }</span>
                            <span class="fragment">console.log(iterator.next()) // { value: 2, done: false }</span>
                            <span class="fragment">console.log(iterator.next()) // { value: 3, done: false }</span>
                            <span class="fragment">console.log(iterator.next()) // { value: 4, done: true }</span>
                        </code></pre>
                    </section>
                </section>

                <section id="modules">
                    <section>
                        <h2>Modules</h2>
                    </section>
                    <section>
                        <h3>Before ES2015</h3>
                        <p>There are several module patterns.</p>
                        <ul>
                            <li class="fragment">
                                Asynchronous Module Definition (AMD)
                                <pre><code data-trim class="js">
                                    define(['someDependency'], function (someDependency) {
                                        return someFunction() { }
                                    })
                                </code></pre>
                            </li>
                            <li class="fragment">
                                CommonJS (mainly used by Node)
                                <pre><code data-trim class="js">
                                    const someDependency = require('someDependency')
                                    module.exports = someFunction() { }
                                </code></pre>
                            </li>
                            <li class="fragment">
                                Universal Module Definition (UMD): supports both AMD and CommonJS
                            </li>
                        </ul>
                    </section>
                    <section>
                        <h3>Exporting: named exports</h3>
                        <pre class="fragment" data-fragment-index="1"><code data-trim data-noescape class="js">
                            export function someFunction() { }
                            <span class="fragment" data-fragment-index="2">export let someString = 'hey'</span>
                            <span class="fragment" data-fragment-index="3">
                            const someArray = [1, 2, 3]
                            const someNumber = 10
                            // export multiple members:
                            export { someArray, someNumber }
                            </span><span class="fragment" data-fragment-index="4">
                            // with a different name:
                            const anotherArray = [4, 5, 6]
                            export { anotherArray as blah }
                            </span><span class="fragment" data-fragment-index="5">
                            // later:
                            someString = 'something else'
                            </span>
                        </code></pre>
                        <p class="fragment" data-fragment-index="5">Members are exported as <em>bindings</em>: if changed later, the imported value changes too.</p>
                    </section>
                    <section>
                        <h3>Exporting: default exports</h3>
                        <pre class="fragment" data-fragment-index="1"><code data-trim data-noescape class="js">
                            function someFunction() { }
                            export default someFunction
                            <span class="fragment" data-fragment-index="3">
                            export function anotherFunction() { }
                            export function andAnother() { }
                            </span>
                        </code></pre>
                        <ul>
                            <li class="fragment" data-fragment-index="2">There can be only one <code>default</code> per module</li>
                            <li class="fragment" data-fragment-index="3">But it's possible to also have more non-default <code>export</code>s</li>
                        </ul>
                        <p class="fragment" data-fragment-index="4">My advice:</p>
                        <ul>
                            <li class="fragment" data-fragment-index="4">
                                either have a single default <code>export</code> <strong>or</strong>&hellip;
                            </li>
                            <li class="fragment" data-fragment-index="5">
                                multiple non-default <code>export</code>s per module</p>
                            </li>
                        </ul>
                    </section>
                    <section>
                        <h3>Importing</h3>
                        <pre class="fragment" data-fragment-index="1"><code data-trim data-noescape class="js">
                            // import multiple named members:
                            import { someFunction, someString } from 'someModule'
                            <span class="fragment" data-fragment-index="2">
                            // rename an imported member:
                            import { someArray as array } from 'anotherModule'
                            </span><span class="fragment" data-fragment-index="3">
                            // import a single default member:
                            import someDefault from 'moduleWithDefault'
                            </span><span class="fragment" data-fragment-index="4">
                            // import a default member and non-default members:
                            import anotherDefault, { someNumber, someVar } from 'mixedModule'
                            </span><span class="fragment" data-fragment-index="5">
                            // a "namespace import" imports <strong>all</strong> members:
                            import * as everything from 'lotsOfMembers'
                            console.log(everything) // { a: 'a', b: 1, c: function c() { } }
                            </span>
                        </code></pre>
                        <p class="fragment" data-fragment-index="6">Imported members are immutable.</p>
                    </section>
                    <section>
                        <h3>Things to keep in mind</h3>
                        <p>ES2015 modules:</p>
                        <ul>
                            <li class="fragment">
                                &hellip;are <strong>file-based</strong>: one module per file.
                            </li>
                            <li class="fragment">
                                &hellip;are <strong>static</strong>: members can't be added/removed dynamically.
                            </li>
                            <li class="fragment">
                                &hellip;are <strong>singletons</strong>: there's one instance of each module, which maintains its state.
                            </li>
                            <li class="fragment">
                                &hellip;support <strong>circular dependencies</strong>: e.g. A imports B and B imports A.
                            </li>
                            <li class="fragment">
                                &hellip;are <strong>very difficult to implement</strong>: no JS runtime currently supports modules.
                            </li>
                        </ul>
                    </section>
                </section>

                <section id="classes">
                    <section>
                        <h2>"Classes"</h2>
                    </section>
                    <section>
                        <h3>Not really though 😒</h3>
                        <p class="fragment" data-fragment-index="1">The word "class" implies <em>class inheritance</em>, but JS still has <em>prototypal inheritance</em>.</p>
                        <pre class="fragment" data-fragment-index="2"><code data-trim data-noescape class="js">
                        class Foo {}
                        console.log(typeof Foo) // function
                        </code></pre>
                        <p class="fragment" data-fragment-index="2"><code>class</code> is just syntactic sugar for a constructor function.</p>
                    </section>
                    <section>
                        <h3><code>class</code> vs. constructor function</h3>
                        <div class="cols">
                            <div class="col fragment small" data-fragment-index="1">
                                <pre><code data-trim data-noescape class="js">
                                    class FooClass {
                                        constructor (a, b) {
                                            this.a = a
                                            this.b = b
                                        }<span class="fragment" data-fragment-index="6"> // ← no comma</span>

                                        aTimesB() {
                                            return this.a * this.b
                                        }
                                    }

                                    const foo = new FooClass(2, 3)
                                    console.log(foo.aTimesB()) // 6
                                </code></pre>
                            </div>
                            <div class="col fragment small" data-fragment-index="2">
                                <pre><code data-trim data-noescape class="js">
                                    function FooConstructor(a, b) {
                                        this.a = a
                                        this.b = b
                                    }

                                    FooConstructor.prototype.aTimesB =
                                        function () {
                                            return this.a * this.b
                                        }


                                    const foo = new FooConstructor(2, 3)
                                    console.log(foo.aTimesB()) // 6
                                </code></pre>
                            </div>
                        </div>
                        <p class="fragment" data-fragment-index="3">Some differences:</p>
                        <ul>
                            <li class="fragment" data-fragment-index="4">
                                Instantiating a <code>class</code> <em>must</em> be done with <code>new</code>.
                            </li>
                            <li class="fragment" data-fragment-index="5">
                                A (constructor) function is hoisted, a <code>class</code> is not.
                            </li>
                        </ul>
                    </section>
                    <section>
                        <h3><code>extends</code> and <code>super</code></h3>
                        <pre class="fragment" data-fragment-index="1"><code data-trim data-noescape class="js small">
                            class Bar extends FooClass {
                                constructor (a, b, c) {
                                    super(a, b)<span class="fragment" data-fragment-index="2"> // here super refers to parent <strong>constructor</strong>: FooClass</span>
                                    this.c = c
                                }

                                aTimesBTimesC() {
                                    <span class="fragment" data-fragment-index="3">// here super refers to parent <strong>object</strong>: FooClass.prototype</span>
                                    return super.aTimesB() * this.c
                                }
                            }

                            const bar = new Bar(2, 3, 4)
                            console.log(bar.aTimesBTimesC()) // 24
                        </code></pre>
                    </section>
                    <section>
                        <h3>Some nuances</h3>
                        <ul>
                            <li class="fragment">
                                <code>super</code> can't be dynamically bound like <code>this</code> can.
                            </li>
                            <li class="fragment">
                                When a class doesn't have a constructor, a default constructor is used. In case of a subclass, the default constructor calls the parent constructor:
                                <pre><code data-trim class="js">
                                    constructor(...args) {
                                        super(...args)
                                    }
                                </code></pre>
                            </li>
                            <li class="fragment">
                                In the constructor of a subclass, you cannot access <code>this</code> until <code>super()</code> has been called.
                            </li>
                        </ul>
                    </section>
                    <section>
                        <h3><code>static</code> methods</h3>
                        <pre class="fragment"><code data-trim data-noescape class="js">
                            class Parent {
                                static foo() { console.log('foo') }
                            }
                            <span class="fragment">
                            class Child extends Parent {
                                static bar() {
                                    super.foo()
                                    console.log('bar')
                                }
                            }</span>

                            <span class="fragment">console.log(Parent.foo()) // 'foo'</span>
                            <span class="fragment">console.log(Child.foo())  // 'foo'</span>
                            <span class="fragment">console.log(Child.bar())  // 'foo' 'bar'</span>
                        </code></pre>
                        <p class="fragment">
                            This works because not only <code>Child.prototype</code> is prototype-linked to <code>Parent.prototype</code>, but <code>Child()</code> is prototype-linked to <code>Parent()</code> too.
                        </p>
                    </section>
                </section>

                <section id="maps-and-sets">
                    <section>
                        <h2><code>Map</code>s and <code>Set</code>s</h2>
                    </section>
                    <section>
                        <h3><code>Map()</code></h3>
                        <p class="fragment">
                            Maps are like objects, but the keys can be of any type.
                        </p>
                        <pre class="fragment"><code data-trim data-noescape class="js">
                            const map = new Map()
                            <span class="fragment">const someNumber = 1
                            const someObject = { b: 2 }
                            </span><span class="fragment">
                            map.set(someNumber,  'a number')
                            map.set(someObject, 'an object')
                            </span><span class="fragment">
                            console.log(map.has(someNumber)) // true</span>
                            <span class="fragment">console.log(map.get(someNumber), map.get(someObject))
                            // 'a number', 'an object'
                            </span><span class="fragment">console.log(map.size) // 2
                            </span><span class="fragment">console.log(map.delete(someNumber)) // true
                            </span><span class="fragment">
                            map.clear()
                            console.log(map.size) // 0
                            </span>
                        </code></pre>
                    </section>
                    <section>
                        <h3>Maps and iterators</h3>
                        <p class="fragment">
                            A <code>Map</code> can be created from an iterable where each item is an array with a key and a value:
                        </p>
                        <pre class="fragment"><code data-trim data-noescape class="js">
                            const map = new Map([
                                [ { a: 1 }, 'first' ],
                                [ { b: 2 }, 'second' ]
                            ])<span class="fragment">
                            // entries() returns an iterator with the same format:
                            console.log(map.entries())
                            // MapIterator { [ Object, 'first' ], [ Object, 'second' ] }
                            </span><span class="fragment">
                            // this makes it easy to copy maps:
                            const newMap = new Map(map)
                            console.log(newMap === map) // false
                            </span><span class="fragment">
                            console.log(map.values()) // MapIterator { 'first', 'second' }
                            </span><span class="fragment">console.log(map.keys())
                            // MapIterator { Object {a: 1}, Object {b: 2} }
                            </span>
                        </code></pre>
                    </section>
                    <section>
                        <h3>Maps vs objects</h3>
                        <p class="fragment">Use <strong>maps</strong> when:</p>
                        <ul>
                            <li class="fragment">you need non-string keys</li>
                            <li class="fragment">properties are unknown beforehand</li>
                            <li class="fragment">properties are added/removed dynamically</li>
                            <li class="fragment">properties need to be iterated</li>
                        </ul>
                        <p class="fragment">Use <strong>objects</strong> when:</p>
                        <ul>
                            <li class="fragment">properties are static (e.g. function arguments and configuration)</li>
                            <li class="fragment">values are of different types</li>
                        </ul>
                    </section>
                    <section>
                        <h3><code>Set()</code></h3>
                        <p class="fragment">
                            Sets are like arrays, but all items are unique.
                        </p>
                        <pre class="fragment"><code data-trim data-noescape class="js">
                            const set = new Set()
                            <span class="fragment">const someNumber = 1
                            const someObject = { b: 2 }
                            </span><span class="fragment">
                            set.add(someNumber)
                            set.add(someObject)
                            set.add(someNumber) // duplicate
                            </span><span class="fragment">
                            // duplicates are ignored:
                            console.log(set.size) // 2</span>
                            <span class="fragment">console.log(set.has(someNumber)) // true</span>
                            <span class="fragment">console.log(set.delete(someNumber)) // true
                            </span><span class="fragment">
                            set.clear()
                            console.log(set.size) // 0
                            </span>
                        </code></pre>
                    </section>
                    <section>
                        <h3>Sets and iterators</h3>
                        <p class="fragment">
                            A <code>Set</code> can be created from an iterable too:
                        </p>
                        <pre class="fragment"><code data-trim data-noescape class="js">
                            const set = new Set([ { a: 1 }, 'second', 3 ])
                            <span class="fragment">
                            // sets have the same iterator methods:
                            const entries = set.entries()
                            const values = set.values()
                            const keys = set.keys()
                            </span><span class="fragment">
                            // &hellip;which are symmetric to maps:
                            </span><span class="fragment">console.log(entries)
                            // SetIterator { [Object, Object], ['second', 'second'], [3, 3]}</span>
                            <span class="fragment">console.log(values)
                            // SetIterator { Object { a: 1 }, 'second', 3 }</span>
                            <span class="fragment">console.log(keys)
                            // SetIterator { Object { a: 1 }, 'second', 3 }
                            </span>
                        </code></pre>
                    </section>
                    <section>
                        <h3><code>WeakMap()</code> and <code>WeakSet()</code></h3>
                        <ul>
                            <li class="fragment">
                                A <code>WeakMap</code>'s <strong>keys</strong> and a <code>WeakSet</code>'s <strong>values</strong> are held <em>weakly</em>; they can be <em>garbage collected</em>.
                            </li>
                            <li class="fragment">
                                A <code>WeakMap</code>'s <strong>keys</strong> and a <code>WeakSet</code>'s <strong>values</strong> can <em>only</em> be objects (including arrays, functions, etc.).
                            </li>
                            <li class="fragment">
                                Both lack a <code>size</code> property, <code>clear()</code> method and iterator methods.
                            </li>
                        </ul>
                    </section>
                </section>

                <section id="api-additions">
                    <section>
                        <h2>API additions</h2>
                    </section>
                    <section>
                        <h3><code>Array.from()</code></h3>
                        <p>Converts <em>array-like</em> objects into arrays:</p>
                        <pre class="fragment"><code data-trim data-noescape class="js">
                            const arrayLike = {
                                length: 4,
                                2: 'third'
                            }
                            console.log(Array.from(arrayLike))
                            // [undefined, undefined, 'third', undefined]
                            <span class="fragment">
                            // Array.from accepts a map function:
                            const mapper = item => item && item.toUpperCase()
                            console.log(Array.from(arrayLike, mapper))
                            // [undefined, undefined, 'THIRD', undefined]
                            </span>
                        </code></pre>
                        <p class="fragment">Many DOM methods and <code>arguments</code> inside functions are examples of array-like objects.</p>
                    </section>
                    <section>
                        <h3><code>Array.copyWithin()</code></h3>
                        <p>Copies a part of an array to another location in the same array. The arguments:</p>
                        <ol class="fragment">
                            <li><em>target</em>: the index to copy to</li>
                            <li class="fragment"><em>start</em>: the inclusive index to start copying</li>
                            <li class="fragment"><em>end</em><small>optional</small>: the exclusive index to stop copying</li>
                        </ol>
                        <pre class="fragment"><code data-trim data-noescape class="js">
                            [1, 2, 3, 4, 5].copyWithin(3, 0)<span class="fragment">      // [1, 2, 3, 1, 2]</span>
                            <span class="fragment">[1, 2, 3, 4, 5].copyWithin(3, 0, 1)</span><span class="fragment">   // [1, 2, 3, 1, 5]</span>
                            <span class="fragment">// negative arguments start at the end of the array
                            [1, 2, 3, 4, 5].copyWithin(0, -2)</span><span class="fragment">     // [4, 5, 3, 4, 5]</span>
                            <span class="fragment">[1, 2, 3, 4, 5].copyWithin(0, -2, -1)</span> <span class="fragment">// [4, 2, 3, 4, 5]</span>
                            </span>
                        </code></pre>
                    </section>
                    <section>
                        <h3><code>Array.prototype.fill()</code></h3>
                        <p>Fills an array with the passed value:</p>
                        <pre class="fragment"><code data-trim data-noescape class="js">
                            const array = Array.from({ length: 4 })
                            console.log(array.fill(1)) // [ 1, 1, 1, 1 ]
                            <span class="fragment">
                            // optionally takes a start and end argument:
                            console.log(array.fill(1, 1, 3))
                            <span class="fragment">// [ undefined, 1, 1, undefined ]</span>
                            </span>
                        </code></pre>
                    </section>
                    <section>
                        <h3><code>Array.prototype.find()</code></h3>
                        <p>Finds a value in an array:</p>
                        <pre class="fragment"><code data-trim data-noescape class="js">
                            const array = [1, 2, 3, 4, 5]
                            console.log(array.find(val => val === 3)) // 3
                            <span class="fragment">
                            // always returns the first match:
                            console.log(array.find(val => val > 3)) <span class="fragment">  // 4</span>
                            </span>
                        </code></pre>
                    </section>
                    <section>
                        <h3><code>Object.setPrototypeOf()</code></h3>
                        <pre class="fragment"><code data-trim data-noescape class="js">
                            const object1 = {
                                hello() {
                                    console.log('hello')
                                }
                            }
                            const object2 = {}
                            <span class="fragment">
                            Object.setPrototypeOf(object2, object1)
                            console.log(object2.hello()) // 'hello'
                            </span>
                        </code></pre>
                    </section>
                    <section>
                        <h3><code>Object.assign()</code></h3>
                        <p class="fragment">
                            Returns a new object where each <em>source</em> object's <em>own</em> properties are copied:
                        </p>
                        <pre class="fragment"><code data-trim data-noescape class="js">
                            let result = Object.assign({}, { a: 1 }, { b: 2 })
                            <span class="fragment">console.log(result) // { a: 1, b: 2 }</span>
                            <span class="fragment">
                            // later arguments "win":
                            result = Object.assign({}, { a: 1 }, { a: 2 })
                            console.log(result)</span><span class="fragment"> // { a: 2 }</span>
                            <span class="fragment">
                            // "inherited" properties aren't copied
                            const object = Object.setPrototypeOf({}, { a: 'other prototype' })</span>
                            <span class="fragment">result = Object.assign({ a: 'target' }, object)
                            console.log(result)</span><span class="fragment"> // { a: 'target' }</span>
                        </code></pre>
                    </section>
                    <section>
                        <h3><code>String.prototype.repeat()</code></h3>
                        <pre class="fragment"><code data-trim data-noescape class="js">
                            console.log('derptie'.repeat(3)) // 'derptiederptiederptie'
                        </code></pre>
                    </section>
                    <section>
                        <h3><code>String</code> inspection functions</h3>
                        <pre class="fragment" data-fragment-index="1"><code data-trim data-noescape class="js">
                            const string = 'Hey there!'

                            <span class="fragment" data-fragment-index="2">console.log(string.startsWith('Hey'))      // true</span>
                            <span class="fragment" data-fragment-index="6">console.log(string.startsWith('there', 4)) // true</span>

                            <span class="fragment" data-fragment-index="3">console.log(string.endsWith('there!'))     // true</span>
                            <span class="fragment" data-fragment-index="7">console.log(string.endsWith('Hey', 3))     // true</span>

                            <span class="fragment" data-fragment-index="4">console.log(string.includes('th'))         // true</span>
                            <span class="fragment" data-fragment-index="8">console.log(string.includes('Hey', 4))     // false</span>
                        </code></pre>
                        <p class="fragment" data-fragment-index="5">These functions accept an optional <em>start</em> index.</p>
                    </section>
                </section>

                <section id="proxies-and-the-reflect-api">
                    <section>
                        <h2>
                            Proxies and the<br>
                            <code>Reflect</code> API
                        </h2>
                    </section>
                    <section>
                        <h3><code>Proxy</code></h3>
                        <p class="fragment">
                            An object that "wraps" another object so that it replaces that object's interface.
                        </p>
                        <pre class="fragment"><code data-trim data-noescape class="js">
                            const handler = {
                                get: function(target, key) {
                                    return key in target ?
                                        target[key] :
                                        'default'
                                }
                            }
                            const proxy = new Proxy({}, handler)

                            <span class="fragment">proxy.a = 1
                            proxy.b = undefined</span>
                            <span class="fragment">console.log(proxy.a) // 1</span>
                            <span class="fragment">console.log(proxy.b) // undefined</span>
                            <span class="fragment">console.log(proxy.c) // 'default'</span>
                        </code></pre>
                        <p class="fragment">There are many so called <em><a href="https://developer.mozilla.org/nl/docs/Web/JavaScript/Reference/Global_Objects/Proxy#Methods_of_the_handler_object">traps</a></em>.</p>
                    </section>
                    <section>
                        <h3>Revocable proxies</h3>
                        <p class="fragment">Creating proxies that can be revoked later is done a little different:</p>
                        <pre class="fragment"><code data-trim data-noescape class="js">
                            const handler = {
                                get: function(target, key) {
                                    console.log(`accessing: ${key}`)
                                    return target[key]
                                }
                            }
                            // the static method revocable returns an object:
                            const { proxy, revoke } = Proxy.revocable({}, handler)
                            <span class="fragment">
                            proxy.a = 1
                            proxy.a // 'accessing: a'
                            </span><span class="fragment">
                            revoke()
                            console.log(proxy.a) // ⚠️ TypeError
                            </span>
                        </code></pre>
                    </section>
                    <section>
                        <h3>Possible usage</h3>
                        <ul>
                            <li class="fragment">
                                Extension: let the proxy add common behavior to objects, e.g. logging.
                            </li>
                            <li class="fragment">
                                Validation/filtering: let the proxy decide what goes in the target object.
                            </li>
                            <li class="fragment">
                                Fallback: let the proxy handle non-existing methods of the target object. <span class="fragment">To achieve this, add the proxy to the object's prototype chain.</span>
                            </li>
                            <li class="fragment">
                                <a href="https://developer.mozilla.org/nl/docs/Web/JavaScript/Reference/Global_Objects/Proxy#Examples">More</a> and <a href="http://www.2ality.com/2014/12/es6-proxies.html#use-cases-for-proxies">more</a>&hellip;
                            </li>
                        </ul>
                    </section>
                    <section>
                        <h3><code>Reflect</code> maps <code>Proxy</code> traps</h3>
                        <p class="fragment">
                            <code>Reflect</code> is a static object to better forward proxy traps.
                        </p>
                        <pre class="fragment"><code data-trim data-noescape class="js">
                            const target = {
                                get foo() { return this.bar },
                                bar: 'bar'
                            }<span class="fragment">
                            const handler = {
                                get(target, key, receiver) {
                                    if (key === 'bar') { return 'proxy bar' }
                                    console.log('with Reflect: ', Reflect.get(target, key, receiver))
                                    console.log('without Reflect: ', target[key])
                                }
                            }</span><span class="fragment">
                            const proxy = new Proxy(target, handler)
                            proxy.foo</span><span class="fragment">
                            // 'with Reflect: proxy bar'
                            // 'without Reflect: bar'
                            </span>
                        </code></pre>
                    </section>
                    <section>
                        <h3>Functions for keywords</h3>
                        <p class="fragment">
                            <code>Reflect</code> has methods for operations that were previously only possible using keywords:
                        </p>
                        <pre class="fragment"><code data-trim data-noescape class="js">
                            const target = { a: 1, b: 2 }
                            const function SomeConstructor(a, b) { }
                            <span class="fragment">
                            delete target.a
                            Reflect.deleteProperty(target, 'a')
                            </span><span class="fragment">
                            new SomeConstructor(1, 2)
                            Reflect.construct(SomeConstructor, [1, 2])
                            </span><span class="fragment">
                            'b' in target
                            Reflect.has(target, 'b')
                            </span>
                        </code></pre>
                        <p class="fragment">Having functions for keywords is convenient for functional programming.</p>
                    </section>
                </section>

                <section>
                    <h2>The end</h2>
                    <p><small><a href="http://abbekeultjes.nl/presentation-es2015-part-2/">abbekeultjes.nl/presentation-es2015-part-2</a></small></p>
                </section>

            </div>
        </div>

        <script src="lib/js/head.min.js"></script>
        <script src="js/reveal.js"></script>

        <script>
            // More info https://github.com/hakimel/reveal.js#configuration
            Reveal.initialize({
                history: true,

                // More info https://github.com/hakimel/reveal.js#dependencies
                dependencies: [
                    { src: 'plugin/markdown/marked.js' },
                    { src: 'plugin/markdown/markdown.js' },
                    { src: 'plugin/notes/notes.js', async: true },
                    { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
                ]
            });
        </script>
    </body>
</html>
